/*org 0x0
bits 16

;MACROS:
%define ENDL 0x0D, 0x0A

start:
	;Write string
	mov si,msg_hello
	call puts
	
	

.halt:
	cli
	hlt

;Receives a string and prints it out, (ds:si pointer)
puts:
	push si
	push ax
	
.loop:
	lodsb ;loads next char
	or al,al    ;Verify if next is null? 0or0 is 0, anything else is 1
	jz .done
	
	mov ah, 0x0e
	mov bh,0
	int 0x10 ;Interrupts to write
	
	jmp .loop

.done:
	;jump outside loop
	pop bx
	pop ax
	pop si
	ret

;DB NEEDED FOR CONSTANTS
msg_hello: DB 'Hello world!',ENDL,0
*/

#include <stdint.h>
#include "stdio.h"
#include "memory.h"
#include "keyboard.h"
#include "command.h"
#include <hal/hal.h>
#include <stdlib.h>
#include <arch/i686/irq.h>
#include <boot/boot_params.h>
#include "kvfs.h"
#include <arch/i686/disk.h>
#include <arch/i686/fat.h>
#include <arch/i686/io.h>
#include "audio.h"
#include "task_scheduler.h"

extern uint8_t __bss_start;
extern uint8_t __end;

/*
Interrupts:

-Exceptions: Generated by CPU, div by zero, invalid seg error, etc..
-IRQ request: (keyboard,task finish), hardware interrupts
-Software interrupt: Generated by INT instructon, system calls
-ISRs: Interrupt Service Routines

Address 0 is Interrupt Vector Table Address
*/

void crash_me();

unsigned int tick=0;
unsigned int goal_tick=0;
bool tick_beeping=false;

#define TIMER_BEEP_LEN_TICKS 1
#define FREQ_CMD 10

void timer_beep(int ticks,uint32_t freq){
	if (tick_beeping==false){
		play_sound(freq);
		tick_beeping=true;
		goal_tick=tick+ticks;
	}
}

#define PROCESS_ID_REBIND_LANG 1
void timer(Registers* regs){
	tick++;
	
	run_scheduler_loop();
	
	int prc_check=check_process(PROCESS_ID_REBIND_LANG);
	
	if(prc_check!=-1){
		//try_rebind
		timer_beep(TIMER_BEEP_LEN_TICKS,FREQ_CMD);
		
		change_language(prc_check); //keyboard language
		kill_process(PROCESS_ID_REBIND_LANG);
	}
	
	if(tick_beeping==true&&tick>=goal_tick){
		nosound();
		tick_beeping=false;
	}
	
	if(check_for_beep_cmd()==true){
		timer_beep(TIMER_BEEP_LEN_TICKS,FREQ_CMD);
		
		set_beep_cmd(false);
	}
	//printf(".");
}

void __attribute__((section(".entry"))) start(BootParams* boot_params){
    memset(&__bss_start, 0, (&__end) - (&__bss_start));
	//start_pic();
	HAL_init(); //Initialize Hardware Abstraction Layer, GDT and other shit needed for the job.
	init_task_scheduler();
	
	DISK disk;
    /*if (disk_initialize(&disk, boot_params->BootDevice)==false){
        printf(DISK_ERR MSG_DELIM ERR_INIT);
        goto end;
    }*/
	/*printf(BOOT_MSG MSG_DELIM INFO_FAT_INI);
    if (FAT_Initialize(&disk)==false){
        printf(FAT_ERR MSG_DELIM ERR_INIT);
        goto end;
    }*/
	
	display_startup();
	display_motd();
    printf("Type 'help' for help.\n");
	
	if (boot_params->initrd_ptr != NULL ) {
		printf("Initrd loaded at %p, size %u bytes\n",boot_params->initrd_ptr,boot_params->initrd_size);
		initrd=(char*)boot_params->initrd_ptr;
		initrd_size=boot_params->initrd_size;

	}
	
	if(readFromBoot(boot_params->FileEntries,boot_params->file_count)==true){
		printf("Files are loaded successfully from boot!\n");
	} else {
		printf("Failed to read in boot files!\n");
	}
	
	init_keyboard();
	i686_IRQ_reg_handlers(0,timer);
	
end:
    for (;;);
}
