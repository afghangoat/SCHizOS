/*org 0x0
bits 16

;MACROS:
%define ENDL 0x0D, 0x0A

start:
	;Write string
	mov si,msg_hello
	call puts
	
	

.halt:
	cli
	hlt

;Receives a string and prints it out, (ds:si pointer)
puts:
	push si
	push ax
	
.loop:
	lodsb ;loads next char
	or al,al    ;Verify if next is null? 0or0 is 0, anything else is 1
	jz .done
	
	mov ah, 0x0e
	mov bh,0
	int 0x10 ;Interrupts to write
	
	jmp .loop

.done:
	;jump outside loop
	pop bx
	pop ax
	pop si
	ret

;DB NEEDED FOR CONSTANTS
msg_hello: DB 'Hello world!',ENDL,0
*/

#include <stdint.h>
#include "stdio.h"
#include "memory.h"
#include "keyboard.h"
#include "command.h"
#include <hal/hal.h>
#include <stdlib.h>
#include <arch/i686/irq.h>
#include <boot/boot_params.h>
#include <arch/i686/disk.h>
#include <arch/i686/fat.h>
#include <arch/i686/io.h>
#include "audio.h"
#include "task_scheduler.h"

extern uint8_t __bss_start;
extern uint8_t __end;

/*
Interrupts:

-Exceptions: Generated by CPU, div by zero, invalid seg error, etc..
-IRQ request: (keyboard,task finish), hardware interrupts
-Software interrupt: Generated by INT instructon, system calls
-ISRs: Interrupt Service Routines

Address 0 is Interrupt Vector Table Address
*/

void crash_me();

unsigned int tick=0;
unsigned int goal_tick=0;
bool tick_beeping=false;

#define TIMER_BEEP_LEN_TICKS 1
#define FREQ_CMD 10

void timer_beep(int ticks,uint32_t freq){
	if (tick_beeping==false){
		play_sound(freq);
		tick_beeping=true;
		goal_tick=tick+ticks;
	}
}

#define PROCESS_ID_REBIND_LANG 1
void timer(Registers* regs){
	tick++;
	
	int prc_check=check_process(PROCESS_ID_REBIND_LANG);
	
	if(prc_check!=-1){
		//try_rebind
		timer_beep(TIMER_BEEP_LEN_TICKS,FREQ_CMD);
		
		change_language(prc_check); //keyboard language
		kill_process(PROCESS_ID_REBIND_LANG);
	}
	
	if(tick_beeping==true&&tick>=goal_tick){
		nosound();
		tick_beeping=false;
	}
	
	if(check_for_beep_cmd()==true){
		timer_beep(TIMER_BEEP_LEN_TICKS,FREQ_CMD);
		
		set_beep_cmd(false);
	}
	//printf(".");
}

void __attribute__((section(".entry"))) start(BootParams* boot_params){
    memset(&__bss_start, 0, (&__end) - (&__bss_start));
	//start_pic();
	HAL_init(); //Initialize Hardware Abstraction Layer, GDT and other shit needed for the job.
	init_task_scheduler();
	
	DISK disk;
    /*if (disk_initialize(&disk, boot_params->BootDevice)==false){
        printf(DISK_ERR MSG_DELIM ERR_INIT);
        goto end;
    }*/
	/*printf(BOOT_MSG MSG_DELIM INFO_FAT_INI);
    if (FAT_Initialize(&disk)==false){
        printf(FAT_ERR MSG_DELIM ERR_INIT);
        goto end;
    }*/
	
	display_startup();
	display_motd();
    printf("Type 'help' for help.\n");
	
	// browse files in root
    /*FAT_File* file_data = FAT_Open(&disk, "/");
    FAT_DirectoryEntry entry;
    int i = 0;
    while (FAT_ReadEntry(&disk, file_data, &entry) && i++ < 5){
        printf(TAB_PAD);
        for (int i = 0; i < 11; i++)
            putc(entry.Name[i]);
        printf("\r\n");
    }
    FAT_Close(file_data);*/
	//puts("Hello world from C!\r\n");
	//printf("AAAA %s aaa %d","bb",21);

	/*
    // read test.txt
    char buffer[100];
    uint32_t read;
    file_data = FAT_Open(&disk, "mydir/test.txt");
    while ((read = FAT_Read(&disk, file_data, sizeof(buffer), buffer))){
        for (uint32_t i = 0; i < read; i++){
            if (buffer[i] == '\n'){
                putc('\r');
			}
            putc(buffer[i]);
        }
    }
    FAT_Close(file_data);*/
	//putc('x');
	
	/*printf("Boot device: %x",boot_params->BootDevice);
	for (int i = 0; i < boot_params->Memory.RegionCount; i++) 
    {
        printf("MEM: start=0x%llx length=0x%llx type=%x", 
            boot_params->Memory.Regions[i].Begin,
            boot_params->Memory.Regions[i].Length,
            boot_params->Memory.Regions[i].Type);
    }*/
	//__asm("int $0x2");
	//printf("Hello world from kernel!!!\n");
	//int a=seeded_rand();
	//printf("x%dx",a);
	//crash_me();
	init_keyboard();
	i686_IRQ_reg_handlers(0,timer);
	
end:
    for (;;);
}
